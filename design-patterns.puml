@startuml Design Patterns in Invoice Manager

!theme plain

title Design Patterns Implementation

package "Singleton Pattern" #LightBlue {
    class DIContainer {
        - instance: DIContainer {static}
        - DIContainer()
        + getInstance(): DIContainer {static}
        + getInvoiceDAOGateway(): InvoiceDAOGateway
        + getInvoiceListControl(): InvoiceListControl
        + reset(): void
    }
    
    note right of DIContainer
        <b>Singleton Pattern</b>
        - Ensures only one instance
        - Thread-safe lazy initialization
        - Manages application dependencies
    end note
}

package "Factory Pattern" #LightGreen {
    class InvoiceFactory {
        + createInvoice(dto: InvoiceDTO): Invoice {static}
        - validateDTO(dto: InvoiceDTO): void {static}
    }
    
    abstract class Invoice {
        + {abstract} calculateTotal(): double
        + {abstract} type(): String
    }
    
    class HourlyInvoice {
        + calculateTotal(): double
        + type(): String
    }
    
    class DailyInvoice {
        + calculateTotal(): double
        + type(): String
    }
    
    InvoiceFactory ..> Invoice : creates
    Invoice <|-- HourlyInvoice
    Invoice <|-- DailyInvoice
    
    note right of InvoiceFactory
        <b>Factory Pattern</b>
        - Creates objects without specifying exact class
        - Encapsulates object creation logic
        - Easy to extend for new invoice types
    end note
}

package "Template Method Pattern" #LightYellow {
    abstract class Invoice {
        # id: String
        # date: Date
        # customer: String
        # room_id: String
        # unitPrice: double
        + {abstract} calculateTotal(): double
        + {abstract} type(): String
        + getId(): String
        + getDate(): Date
    }
    
    class HourlyInvoice {
        - hour: int
        + calculateTotal(): double {
            if (hour <= 0) return 0;
            else if (hour >= 24 && hour <= 30) return 24 * unitPrice;
            else if (hour > 30) return -1;
            else return hour * unitPrice;
        }
    }
    
    class DailyInvoice {
        - day: int
        + calculateTotal(): double {
            if (day <= 0) return 0;
            else if (day > 7) return 7 * unitPrice + (day - 7) * unitPrice * 0.8;
            else return day * unitPrice;
        }
    }
    
    Invoice <|-- HourlyInvoice
    Invoice <|-- DailyInvoice
    
    note right of Invoice
        <b>Template Method Pattern</b>
        - Defines skeleton of algorithm
        - Subclasses implement specific steps
        - calculateTotal() has different logic per type
    end note
}

package "Strategy Pattern" #LightCoral {
    interface InvoiceDAOGateway {
        + getAll(): List<InvoiceDTO>
        + add(invoice: InvoiceDTO): boolean
    }
    
    class InvoiceDAO {
        + getAll(): List<InvoiceDTO>
        + add(invoice: InvoiceDTO): boolean
    }
    
    class MockInvoiceDAO {
        + getAll(): List<InvoiceDTO>
        + add(invoice: InvoiceDTO): boolean
    }
    
    InvoiceDAOGateway <|.. InvoiceDAO
    InvoiceDAOGateway <|.. MockInvoiceDAO
    
    note right of InvoiceDAOGateway
        <b>Strategy Pattern</b>
        - Different data access strategies
        - Can switch between implementations
        - Easy testing with mocks
    end note
}

package "Observer Pattern" #LightPink {
    interface Publisher {
        + addSubscriber(subscriber: Subscriber): void
        + removeSubscriber(subscriber: Subscriber): void
        + notifySubscribers(): void
    }
    
    interface Subscriber {
        + update(): void
    }
    
    class PrimaryController {
        + addSubscriber(subscriber: Subscriber): void
        + removeSubscriber(subscriber: Subscriber): void
        + notifySubscribers(): void
    }
    
    class InvoiceListModel {
        + update(): void
    }
    
    Publisher <|.. PrimaryController
    Subscriber <|.. InvoiceListModel
    PrimaryController --> Subscriber : notifies
    
    note right of Publisher
        <b>Observer Pattern</b>
        - Loose coupling between UI components
        - Automatic updates when data changes
        - Event-driven architecture
    end note
}

package "Dependency Injection" #LightSalmon {
    class InvoiceListControl {
        - invoiceDAOGateway: InvoiceDAOGateway
        + InvoiceListControl(gateway: InvoiceDAOGateway)
    }
    
    class addInvoice {
        - invoiceDAOGateway: InvoiceDAOGateway
        + addInvoice(gateway: InvoiceDAOGateway)
    }
    
    DIContainer --> InvoiceListControl : injects dependencies
    DIContainer --> addInvoice : injects dependencies
    
    note right of InvoiceListControl
        <b>Dependency Injection</b>
        - Constructor injection
        - Loose coupling
        - Easy unit testing
        - Inversion of Control
    end note
}

package "Service Layer Pattern" #LightSeaGreen {
    class StatisticsService {
        + calculateTotalRevenue(invoices: List<Invoice>): double {static}
        + countInvoices(invoices: List<Invoice>): int {static}
        + calculateAverageRevenue(invoices: List<Invoice>): double {static}
        + countInvoicesByType(invoices: List<Invoice>, type: String): long {static}
    }
    
    class InvoiceConverter {
        + convertDTOsToInvoiceListItems(dtoList: List<InvoiceDTO>): List<InvoiceListItem> {static}
        + convertDTOToInvoiceListItem(dto: InvoiceDTO): InvoiceListItem {static}
        + convertDTOsToBusinessObjects(dtoList: List<InvoiceDTO>): List<Invoice> {static}
    }
    
    note right of StatisticsService
        <b>Service Layer Pattern</b>
        - Business logic in services
        - Stateless operations
        - Reusable across controllers
        - Single Responsibility
    end note
}

@enduml
